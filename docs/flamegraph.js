/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bin/flamegraph.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@asgerf/strongcli/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@asgerf/strongcli/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OptionParserBuilder = /** @class */ (function () {\n    function OptionParserBuilder(parserSettings) {\n        this.parserSettings = parserSettings;\n    }\n    /**\n     * Parse command-line arguments with given option specification.\n     *\n     * The type argument should refer to the desired parsed options.\n     *\n     * For example:\n     * ```typescript\n     * interface MyOptions {\n     *   verbose: boolean;\n     *   name: string;\n     * }\n     * let { options, args } = cli.program('foo').main<MyOptions>({\n     *   verbose: {\n     *     alias: '-v'\n     *   },\n     *   name: {\n     *     value: String\n     *   }\n     * });\n     * ```\n     */\n    OptionParserBuilder.prototype.main = function (options) {\n        return new OptionParser(options, this.parserSettings).main();\n    };\n    /**\n     * Create a CLI parser using the given option specification.\n     *\n     * The type argument should refer to the desired parsed options.\n     *\n     * For example:\n     * ```typescript\n     * interface MyOptions {\n     *   verbose: boolean;\n     *   name: string;\n     * }\n     * let parser = cli.program('my-program').parser<MyOptions>({\n     *   verbose: {\n     *     alias: '-v'\n     *   },\n     *   name: {\n     *     value: String\n     *   }\n     * });\n     * ```\n     */\n    OptionParserBuilder.prototype.parser = function (options) {\n        return new OptionParser(options, this.parserSettings);\n    };\n    /**\n     * Create a new CLI parser with subcommands.\n     *\n     * Call `.command()` for each command, and finally call `.main`.\n     *\n     * For example:\n     * ```typescript\n     *  export interface AddOptions {\n     *      type: string;\n     *      count: number;\n     *  }\n     *  program.command<AddOptions>({\n     *      name: 'add',\n     *      description: 'Adds new things',\n     *      options: {\n     *          type: {\n     *              value: String\n     *          },\n     *          count: {\n     *              value: Number\n     *          }\n     *      },\n     *      callback(options, args) {\n     *          console.log(`Adding ${options.count} of ${options.type} and also: ${args.join(', ')}`);\n     *      },\n     *  });\n     * ```\n     */\n    OptionParserBuilder.prototype.commandSet = function () {\n        return new CommandSet(this.parserSettings);\n    };\n    return OptionParserBuilder;\n}());\n/**\n * Start creating an new CLI parser. Follow up with a call to `.parser()`.\n *\n * For example:\n * ```typescript\n * interface MyOptions {\n *   verbose: boolean;\n *   name: string;\n * }\n * let parser = cli.program('my-program').parser<MyOptions>({\n *   verbose: {\n *     alias: '-v'\n *   },\n *   name: {\n *     value: String\n *   }\n * });\n * ```\n */\nfunction program(settings) {\n    if (typeof settings === 'string') {\n        settings = { name: settings };\n    }\n    return new OptionParserBuilder(settings);\n}\nexports.program = program;\n/**\n * Create a new CLI parser using the given option specification.\n *\n * The type argument should refer to the desired parsed options.\n *\n * For example:\n * ```typescript\n * interface MyOptions {\n *   verbose: boolean;\n *   name: string;\n * }\n * let parser = cli.parser<MyOptions>({\n *   verbose: {\n *     alias: '-v'\n *   },\n *   name: {\n *     value: String\n *   }\n * });\n * ```\n */\nfunction parser(options) {\n    return new OptionParser(options, undefined);\n}\nexports.parser = parser;\n/**\n * Parse command-line arguments with given option specification.\n *\n * The type argument should refer to the desired parsed options.\n *\n * For example:\n * ```typescript\n * interface MyOptions {\n *   verbose: boolean;\n *   name: string;\n * }\n * let { options, args } = cli.main<MyOptions>({\n *   verbose: {\n *     alias: '-v'\n *   },\n *   name: {\n *     value: String\n *   }\n * });\n * ```\n */\nfunction main(options) {\n    return parser(options).main();\n}\nexports.main = main;\n/**\n * Create a new CLI parser with subcommands.\n *\n * Call `.command()` for each command, and finally call `.main`.\n *\n * For example:\n * ```typescript\n *  export interface AddOptions {\n *      type: string;\n *      count: number;\n *  }\n *  program.command<AddOptions>({\n *      name: 'add',\n *      description: 'Adds new things',\n *      options: {\n *          type: {\n *              value: String\n *          },\n *          count: {\n *              value: Number\n *          }\n *      },\n *      callback(options, args) {\n *          console.log(`Adding ${options.count} of ${options.type} and also: ${args.join(', ')}`);\n *      },\n *  });\n * ```\n */\nfunction commandSet(settings) {\n    return program(settings).commandSet();\n}\nexports.commandSet = commandSet;\n/**\n * A CLI option parser, usually created using `cli.parser()` or `cli.program().parser()`.\n */\nvar OptionParser = /** @class */ (function () {\n    /**\n     * Creates a new CLI option parser directly.\n     *\n     * This is usually not called directly, instead prefer `cli.parser` or `cli.program().parser()`.\n     */\n    function OptionParser(options, parserSettings, outerProgramName) {\n        this.options = options;\n        this.outerProgramName = outerProgramName;\n        this.shortCharToName = new Map();\n        this.longOptionToName = new Map();\n        this.parserSettings = parserSettings || {};\n        var _a = this, shortCharToName = _a.shortCharToName, longOptionToName = _a.longOptionToName;\n        this.optionKeys = Object.keys(options);\n        var plainObj = {};\n        for (var _i = 0, _b = this.optionKeys; _i < _b.length; _i++) {\n            var key = _b[_i];\n            if (key in plainObj) {\n                throw new Error(\"The key \" + key + \" clashes with a built-in property.\");\n            }\n            var option = options[key];\n            var names = this.getNamesFromOption(option, key);\n            for (var _c = 0, names_1 = names; _c < names_1.length; _c++) {\n                var name_1 = names_1[_c];\n                if (name_1.startsWith('--')) {\n                    if (name_1.length < 3) {\n                        throw new Error(\"Invalid long option \" + name_1 + \": Long options must be of form \\\"--xxx\\\".\");\n                    }\n                    if (longOptionToName.has(name_1)) {\n                        throw new Error(\"Duplicate option \" + name_1 + \": used by both \" + key + \" and \" + longOptionToName.get(name_1) + \".\");\n                    }\n                    longOptionToName.set(name_1, key);\n                }\n                else if (name_1.startsWith('-')) {\n                    if (name_1.length !== 2) {\n                        throw new Error(\"Invalid short option \" + name_1 + \": Short options must be of form \\\"-x\\\"'.\");\n                    }\n                    var shortChar = name_1.charAt(1);\n                    if (shortCharToName.has(shortChar)) {\n                        throw new Error(\"Duplicate short option \" + name_1 + \": used by both \" + key + \" and \" + shortCharToName.get(shortChar) + \".\");\n                    }\n                    shortCharToName.set(shortChar, key);\n                }\n                else {\n                    throw new Error(\"Invalid name \" + name_1 + \". Must be of form \\\"--xxx\\\" or \\\"-x\\\"\");\n                }\n            }\n        }\n    }\n    OptionParser.prototype.getNamesFromOption = function (option, key) {\n        var names = __spreadArrays(asArray(option.name), asArray(option.alias));\n        if (option.name === undefined) {\n            names.push('--' + camelToKebabCase(key));\n        }\n        return names;\n    };\n    /**\n     * Parses the given command-line arguments and returns the parsed options.\n     *\n     * The argument list should *not* include the first two entries of `process.argv`.\n     * If the argument list is omitted, `process.argv.slice(2)` is used.\n     *\n     * If an exception is thrown, the error is written to stderr without a stack trace, and\n     * the program exits with exit code 1. To handle errors yourself, call `parse` instead\n     * of `main`.\n     */\n    OptionParser.prototype.main = function (args) {\n        try {\n            args = args || process.argv.slice(2);\n            if (args.length === 0 && this.parserSettings.helpIfEmpty) {\n                this.help();\n            }\n            return this.parse(args);\n        }\n        catch (e) {\n            console.error(e instanceof ParseError ? e.toString() : e);\n            process.exit(1);\n        }\n    };\n    OptionParser.prototype.getValueHint = function (fn) {\n        if (fn === Number || fn === parseInt || fn === parseFloat) {\n            return 'num';\n        }\n        if (fn.hint) {\n            return fn.hint;\n        }\n        return 'value';\n    };\n    /**\n     * Returns the program usage help.\n     */\n    OptionParser.prototype.getHelp = function () {\n        var _a = this.parserSettings, positionalArgHint = _a.positionalArgHint, description = _a.description, usage = _a.usage, name = _a.name;\n        if (usage == null) {\n            positionalArgHint = positionalArgHint == null ? '' : \" \" + positionalArgHint;\n            if (name == null) {\n                name = __webpack_require__(/*! path */ \"path\").basename(process.argv[1]);\n            }\n            var outerProgramName = this.outerProgramName;\n            if (outerProgramName != null) {\n                name = outerProgramName + ' ' + name;\n            }\n            usage = \"Usage: \" + name + \" [options]\" + positionalArgHint;\n        }\n        else {\n            usage = this.trimHelp(usage);\n        }\n        description = description == null ? '' : this.trimHelp(getLongDescription(description)) + \"\\n\\n\";\n        var optionHelp = this.getOptionHelp(4);\n        return \"\\n\" + usage + \"\\n\\n\" + description + optionHelp;\n    };\n    /**\n     * Prints the program help text and exits.\n     */\n    OptionParser.prototype.help = function () {\n        console.error(this.getHelp());\n        process.exit(1);\n    };\n    /**\n     * Returns the help generated from all options in the program, with\n     * the given indentation.\n     *\n     * This is included in `getHelp()` but may be useful for constructing your\n     * own help string.\n     */\n    OptionParser.prototype.getOptionHelp = function (indentation) {\n        var _a = this, options = _a.options, optionKeys = _a.optionKeys;\n        var result = 'Options:\\n';\n        var flagColumn = [];\n        var flagColumnWidth = 20;\n        for (var _i = 0, optionKeys_1 = optionKeys; _i < optionKeys_1.length; _i++) {\n            var key = optionKeys_1[_i];\n            var option = options[key];\n            var names = this.getNamesFromOption(option, key).join(', ');\n            if (option.valueHint) {\n                names += ' ' + angleBracket(option.valueHint);\n            }\n            else if (option.value) {\n                var hint = this.getValueHint(option.value);\n                names += ' ' + angleBracket(hint);\n            }\n            flagColumn.push(names);\n            if (names.length > flagColumnWidth) {\n                flagColumnWidth = names.length;\n            }\n        }\n        ++flagColumnWidth; // Leave one space\n        var baseIndent = padRight('', indentation);\n        var descriptionIndent = padRight('', flagColumnWidth + indentation);\n        for (var i = 0; i < flagColumn.length; ++i) {\n            var option = options[optionKeys[i]];\n            var descriptionLines = this.trimHelp(option.description || '').split(/\\n/);\n            result += baseIndent + padRight(flagColumn[i], flagColumnWidth) + descriptionLines[0] + '\\n';\n            for (var j = 1; j < descriptionLines.length; ++j) {\n                result += descriptionIndent + descriptionLines[j] + '\\n';\n            }\n        }\n        return result;\n    };\n    /**\n     * Trims empty lines around the given string unless disabled by `trimHelp: false`.\n     */\n    OptionParser.prototype.trimHelp = function (str) {\n        return this.parserSettings.trimHelp === false\n            ? str\n            : trimLines(str);\n    };\n    /**\n     * Parses the given argument list and returns the parsed options.\n     *\n     * The argument list should *not* include the first two entries of `process.argv`.\n     *\n     * In case invalid options are passed in, a `ParseError` is thrown.\n     */\n    OptionParser.prototype.parse = function (argumentList) {\n        var _a = this, options = _a.options, optionKeys = _a.optionKeys, longOptionToName = _a.longOptionToName, shortCharToName = _a.shortCharToName;\n        var optionArgs = {};\n        var positionalArgs = [];\n        var seenOptions = new Set();\n        // Initialize arrays and flags.\n        for (var _i = 0, optionKeys_2 = optionKeys; _i < optionKeys_2.length; _i++) {\n            var key = optionKeys_2[_i];\n            var option = options[key];\n            if (option.repeatable || option.consumeMultipleArguments) {\n                optionArgs[key] = [];\n            }\n            else if (!option.value) {\n                optionArgs[key] = false;\n            }\n        }\n        for (var i = 0; i < argumentList.length; ++i) {\n            var arg = argumentList[i];\n            if (!arg.startsWith('-')) {\n                positionalArgs.push(arg);\n                continue;\n            }\n            var flag = arg;\n            var valueStr = undefined;\n            var equalsIndex = flag.indexOf('=');\n            if (equalsIndex !== -1) {\n                valueStr = flag.substring(equalsIndex + 1);\n                flag = flag.substring(0, equalsIndex);\n            }\n            var optionName = void 0;\n            if (flag.startsWith('--')) {\n                if (flag.length === 2) {\n                    positionalArgs.push.apply(positionalArgs, argumentList.slice(i + 1));\n                    break;\n                }\n                optionName = longOptionToName.get(flag);\n                if (optionName == null) {\n                    this.fail(arg, \"Unrecognized option '\" + flag + \"'\");\n                }\n            }\n            else {\n                if (equalsIndex !== -1 && flag.length > 2) {\n                    this.fail(arg, \"Combined short arguments may not use '='. Use long-form version or omit the '='.\");\n                }\n                for (var charIndex = 1; charIndex < flag.length; ++charIndex) {\n                    var char = flag.charAt(charIndex);\n                    optionName = shortCharToName.get(char);\n                    if (optionName === undefined) {\n                        this.fail(arg, \"Unrecognized short option '-\" + char + \"'\");\n                    }\n                    var option_1 = options[optionName];\n                    if (option_1.value) {\n                        if (valueStr === undefined && charIndex < flag.length - 1) {\n                            valueStr = flag.substring(charIndex + 1);\n                        }\n                        break;\n                    }\n                    else {\n                        optionArgs[optionName] = true;\n                    }\n                }\n                if (optionName === undefined) { // Happens if argument was just a `-`\n                    this.fail(arg, 'Incomplete argument.');\n                }\n            }\n            var option = options[optionName];\n            if (option.value) {\n                if (valueStr === undefined && i < argumentList.length - 1 && !argumentList[i + 1].startsWith('-')) {\n                    valueStr = argumentList[++i];\n                    arg += ' ' + valueStr;\n                }\n                if (valueStr === undefined && option.consumeMultipleArguments === 'all') {\n                    continue; // Does not need to consume any values.\n                }\n                if (valueStr === undefined) {\n                    this.fail(arg, \"This option takes value.\");\n                }\n                var value = this.parseValue(arg, valueStr, option.value, option.allowNaN);\n                if (option.consumeMultipleArguments) {\n                    value = [value];\n                    if (equalsIndex === -1) {\n                        var stopAtDash = option.consumeMultipleArguments !== 'all';\n                        while (i < argumentList.length - 1 && !(stopAtDash && argumentList[i + 1].startsWith('-'))) {\n                            var nextArg = argumentList[++i];\n                            value.push(this.parseValue(flag + ' ' + nextArg, nextArg, option.value, option.allowNaN));\n                        }\n                    }\n                }\n                if (option.repeatable) {\n                    optionArgs[optionName].push(value);\n                }\n                else if (seenOptions.has(optionName)) {\n                    this.fail(arg, \"This option is not repeatable.\");\n                }\n                else {\n                    optionArgs[optionName] = value;\n                }\n            }\n            else {\n                optionArgs[optionName] = true;\n            }\n            seenOptions.add(optionName);\n        }\n        // Fill in defaults for omitted values. Do this last so they're not confused with repeated values.\n        for (var _b = 0, optionKeys_3 = optionKeys; _b < optionKeys_3.length; _b++) {\n            var key = optionKeys_3[_b];\n            var option = options[key];\n            if (!hasOwnProp(option, 'default') || seenOptions.has(key)) {\n                continue;\n            }\n            var defaultValue = option.default;\n            if (defaultValue === required) {\n                var names = this.getNamesFromOption(option, key);\n                var name_2 = names.find(function (x) { return x.startsWith('--'); }) || names[0] || key;\n                this.fail(name_2, 'This option is required.');\n            }\n            if (typeof defaultValue === 'function') {\n                defaultValue = defaultValue();\n            }\n            if (option.repeatable || option.consumeMultipleArguments) {\n                optionArgs[key] = __spreadArrays(defaultValue);\n            }\n            else if (!hasOwnProp(optionArgs, key)) {\n                optionArgs[key] = defaultValue;\n            }\n        }\n        return {\n            options: optionArgs,\n            args: positionalArgs\n        };\n    };\n    OptionParser.prototype.parseValue = function (arg, valueStr, fn, allowNaN) {\n        var value;\n        try {\n            value = fn(valueStr);\n        }\n        catch (e) {\n            if (e instanceof ParseError) {\n                e.argument = arg;\n            }\n            throw e;\n        }\n        if (!allowNaN && value !== value) {\n            var message = \"Unexpected value '\" + valueStr + \"'.\";\n            if (fn === Number || fn === parseInt) {\n                message += ' This option takes a numeric value.';\n            }\n            this.fail(arg, message);\n        }\n        return value;\n    };\n    OptionParser.prototype.fail = function (arg, message) {\n        throw new ParseError(message, arg);\n    };\n    return OptionParser;\n}());\nexports.OptionParser = OptionParser;\n/**\n * Exception that can be thrown by the `value` function of an option to indicate\n * that an error should be displayed for that option.\n */\nvar ParseError = /** @class */ (function () {\n    function ParseError(message, argument) {\n        this.message = message;\n        this.argument = argument;\n    }\n    ParseError.prototype.toString = function () {\n        var _a = this, argument = _a.argument, message = _a.message;\n        return argument === undefined ? message : (argument + ': ' + message);\n    };\n    return ParseError;\n}());\nexports.ParseError = ParseError;\n/**\n * Similar to `Number` except only integers are allowed.\n *\n * Throws a `ParseError` if the value could not be parsed as an integer.\n */\nfunction integer(x) {\n    var value = Number(x);\n    if ((value | 0) !== value) {\n        throw new ParseError(\"Unexpected value '\" + x + \"'. This option takes an integer.\");\n    }\n    return value;\n}\nexports.integer = integer;\nfunction asArray(x) {\n    if (x == null) {\n        return [];\n    }\n    if (Array.isArray(x)) {\n        return x;\n    }\n    return [x];\n}\nfunction hasOwnProp(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction camelToKebabCase(str) {\n    return str.replace(/[a-z][A-Z]|[A-Z]{2}[a-z]/g, function (x) { return x.charAt(0) + '-' + x.substring(1); }).toLowerCase();\n}\nfunction angleBracket(str) {\n    return str.charAt(0) === '<' ? str : \"<\" + str + \">\";\n}\nfunction padRight(str, len) {\n    while (str.length < len) {\n        str += ' ';\n    }\n    return str;\n}\nvar CommandSet = /** @class */ (function () {\n    function CommandSet(settings) {\n        this.commands = new Map();\n        this.commandParsers = new Map();\n        this.settings = settings || {};\n        this.command({\n            name: 'help',\n            description: 'Show help for a command',\n            positionalArgHint: '<cmd>',\n            options: {},\n            callback: this.helpCommand.bind(this)\n        });\n    }\n    /**\n     * Adds a new command to the command set.\n     *\n     * For example:\n     * ```typescript\n     *  export interface AddOptions {\n     *      type: string;\n     *      count: number;\n     *  }\n     *  program.command<AddOptions>({\n     *      name: 'add',\n     *      description: 'Adds new things',\n     *      options: {\n     *          type: {\n     *              value: String\n     *          },\n     *          count: {\n     *              value: Number\n     *          }\n     *      },\n     *      callback(options, args) {\n     *          console.log(`Adding ${options.count} of ${options.type} and also: ${args.join(', ')}`);\n     *      },\n     *  });\n     * ```\n     */\n    CommandSet.prototype.command = function (settings) {\n        var _a = this, commands = _a.commands, commandParsers = _a.commandParsers;\n        var name = settings.name;\n        if (commands.has(name)) {\n            throw new Error(\"Duplicate command '\" + name + \"'\");\n        }\n        commandParsers.set(name, new OptionParser(settings.options, settings, this.settings.name));\n        commands.set(name, settings);\n    };\n    /**\n     * Parses the given command-line arguments and executes its callback function/\n     *\n     * The argument list should *not* include the first two entries of `process.argv`.\n     * If the argument list is omitted, `process.argv.slice(2)` is used.\n     *\n     * If an exception is thrown, the error is written to stderr without a stack trace, and\n     * the program exits with exit code 1. To handle errors yourself, call `parse` instead\n     * of `main`.\n     */\n    CommandSet.prototype.main = function (args) {\n        if (args == null) {\n            args = process.argv.slice(2);\n        }\n        if (args.length === 0) {\n            this.help();\n        }\n        var command = args[0];\n        var optionParser = this.commandParsers.get(command);\n        if (optionParser == null) {\n            throw new ParseError(\"Unrecognized command '\" + command + \"'\");\n        }\n        var parsedCommand = optionParser.main(args.slice(1));\n        this.commands.get(command).callback.call(undefined, parsedCommand.options, parsedCommand.args);\n    };\n    /**\n     * Parses the given argument list and returns the command and its parsed options.\n     *\n     * The argument list should *not* include the first two entries of `process.argv`.\n     *\n     * In case invalid options are passed in, a `ParseError` is thrown.\n     */\n    CommandSet.prototype.parse = function (args) {\n        if (args.length === 0) {\n            throw new ParseError('No command was given');\n        }\n        var command = args[0];\n        var optionParser = this.commandParsers.get(command);\n        if (optionParser == null) {\n            throw new ParseError(\"Unrecognized command '\" + command + \"'\");\n        }\n        var result = optionParser.parse(args.slice(1));\n        result.command = command;\n        return result;\n    };\n    /**\n     * Parses the given command and executes its callback function.\n     *\n     * Unlike `main`, this will not write to the console or call `process.exit`.\n     */\n    CommandSet.prototype.execute = function (args) {\n        var parsedCommand = this.parse(args);\n        this.commands.get(parsedCommand.command).callback.call(undefined, parsedCommand.options, parsedCommand.args);\n        return parsedCommand;\n    };\n    /**\n     * Prints the program help text and exits.\n     */\n    CommandSet.prototype.help = function () {\n        console.error(this.getHelp());\n        process.exit(1);\n    };\n    /** Returns the usage string and list of command names. */\n    CommandSet.prototype.getHelp = function () {\n        var _a = this.settings, description = _a.description, usage = _a.usage, name = _a.name;\n        if (usage == null) {\n            if (name == null) {\n                name = __webpack_require__(/*! path */ \"path\").basename(process.argv[1]);\n            }\n            usage = \"Usage: \" + name + \" command [<args>]\";\n        }\n        description = description == null ? '' : description + \"\\n\\n\";\n        var commandHelp = this.getCommandOverview(4);\n        return \"\\n\" + usage + \"\\n\\n\" + description + commandHelp;\n    };\n    /** Returns the list of subcommands. */\n    CommandSet.prototype.getCommands = function () {\n        return Array.from(this.commands.keys());\n    };\n    /** Returns the parser for the given subcommand. */\n    CommandSet.prototype.getSubcommand = function (command) {\n        var optionParser = this.commandParsers.get(command);\n        if (optionParser == null) {\n            throw new Error(\"Unrecognized command: \" + command);\n        }\n        return optionParser;\n    };\n    CommandSet.prototype.getCommandOverview = function (indentation) {\n        var result = 'Commands:\\n';\n        var verbs = Array.from(this.commands).map(function (_a) {\n            var name = _a[0], cmd = _a[1];\n            if (cmd.positionalArgHint != null) {\n                name += ' ' + cmd.positionalArgHint;\n            }\n            return name;\n        });\n        var commandWidth = 4 + Math.max.apply(Math, __spreadArrays([8], verbs.map(function (x) { return x.length; })));\n        var indent = padRight('', indentation);\n        var index = 0;\n        this.commands.forEach(function (commandParser) {\n            var name = verbs[index++];\n            result += indent + padRight(name, commandWidth) + getBriefDescription(commandParser.description) + '\\n';\n        });\n        return result;\n    };\n    CommandSet.prototype.helpCommand = function (options, args) {\n        if (args.length === 0) {\n            this.help();\n        }\n        var command = args[0];\n        var optionParser = this.commandParsers.get(command);\n        if (optionParser == null) {\n            console.error(\"Unrecognized command: '\" + command + \"'\");\n            process.exit(1);\n        }\n        optionParser.help();\n    };\n    return CommandSet;\n}());\nexports.CommandSet = CommandSet;\nfunction getBriefDescription(description) {\n    if (description == null) {\n        return '';\n    }\n    else if (typeof description === 'string') {\n        var eol = description.search(/\\r|\\n/);\n        return eol === -1 ? description : description.substring(0, eol);\n    }\n    else {\n        return description.brief;\n    }\n}\nfunction getLongDescription(description) {\n    if (description == null) {\n        return '';\n    }\n    else if (typeof description === 'string') {\n        return description;\n    }\n    else {\n        return description.long;\n    }\n}\nfunction trimLines(str) {\n    return str.trimRight().replace(/^\\s+(?<=[\\r\\n])/, '');\n}\n/**\n * Use as the `default` value to mark an option as required.\n *\n * For example:\n * ```typescript\n * interface Options {\n *   foo: number;\n * }\n * cli.main<Options>{\n *   foo: {\n *     value: Number,\n *     default: cli.required // note: do not call cli.required()\n *   }\n * }\n * ```\n *\n * Specifically, this function immediately throws a `ParseError` with the message \"This option is required\".\n */\nfunction required() {\n    throw new Error('Do not call this function. Just set it to the default.');\n}\nexports.required = required;\n/**\n * Use as the `value` option to accept only one of specified values.\n *\n * If given an array, accepts any of the values and returns the value itself.\n *\n * If given an object, accepts any of the own properties of that object and returns the\n * value of the corresponding property.\n *\n * If used in combination with an enum declaration, it works best if the enum\n * values are initialized to their own name.\n *\n * For example:\n * ```ts\n * enum Format {\n *   html = 'html',\n *   markdown = 'markdown',\n * }\n *\n * interface Options {\n *   format: Format;\n * }\n *\n * let { options, args } = cli.main<Options>({\n *   format: {\n *     value: cli.oneOf(Format),\n *     default: Format.html,\n *     description: `The format to use. Defaults to 'html.'\\n` +\n *       `Possible values are ${Object.keys(Format).join(', ')}.`\n *   }\n * })\n * ```\n */\nfunction oneOf(values) {\n    if (Array.isArray(values)) {\n        return function (arg) {\n            if (!values.includes(arg)) {\n                throw new ParseError('Must be one of ' + values.join(', '));\n            }\n            return arg;\n        };\n    }\n    else {\n        return function (arg) {\n            if (!hasOwnProp(values, arg)) {\n                throw new ParseError('Must be one of ' + Object.keys(values).join(', '));\n            }\n            return values[arg];\n        };\n    }\n}\nexports.oneOf = oneOf;\n/**\n * Prints the given message to stderr and terminates the process with exit code 1.\n */\nfunction fail(message) {\n    console.error(message);\n    process.exit(1);\n}\nexports.fail = fail;\n\n\n//# sourceURL=webpack:///./node_modules/@asgerf/strongcli/index.js?");

/***/ }),

/***/ "./node_modules/is-docker/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-docker/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n\nlet isDocker;\n\nfunction hasDockerEnv() {\n\ttry {\n\t\tfs.statSync('/.dockerenv');\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n}\n\nfunction hasDockerCGroup() {\n\ttry {\n\t\treturn fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');\n\t} catch (_) {\n\t\treturn false;\n\t}\n}\n\nmodule.exports = () => {\n\tif (isDocker === undefined) {\n\t\tisDocker = hasDockerEnv() || hasDockerCGroup();\n\t}\n\n\treturn isDocker;\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-docker/index.js?");

/***/ }),

/***/ "./node_modules/is-wsl/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-wsl/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst isDocker = __webpack_require__(/*! is-docker */ \"./node_modules/is-docker/index.js\");\n\nconst isWsl = () => {\n\tif (process.platform !== 'linux') {\n\t\treturn false;\n\t}\n\n\tif (os.release().toLowerCase().includes('microsoft')) {\n\t\tif (isDocker()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\ttry {\n\t\treturn fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ?\n\t\t\t!isDocker() : false;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n\nif (process.env.__IS_WSL_TEST__) {\n\tmodule.exports = isWsl;\n} else {\n\tmodule.exports = isWsl();\n}\n\n\n//# sourceURL=webpack:///./node_modules/is-wsl/index.js?");

/***/ }),

/***/ "./node_modules/lodash.escape/index.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash.escape/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match HTML entities and HTML characters. */\nvar reUnescapedHtml = /[&<>\"'`]/g,\n    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n/** Used to map characters to HTML entities. */\nvar htmlEscapes = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '`': '&#96;'\n};\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyOf(object) {\n  return function(key) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Used by `_.escape` to convert characters to HTML entities.\n *\n * @private\n * @param {string} chr The matched character to escape.\n * @returns {string} Returns the escaped character.\n */\nvar escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\" in `string` to\n * their corresponding HTML entities.\n *\n * **Note:** No other characters are escaped. To escape additional\n * characters use a third-party library like [_he_](https://mths.be/he).\n *\n * Though the \">\" character is escaped for symmetry, characters like\n * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n * unless they're part of a tag or unquoted attribute value. See\n * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n * (under \"semi-related fun fact\") for more details.\n *\n * Backticks are escaped because in IE < 9, they can break out of\n * attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n * [#133](https://html5sec.org/#133) of the\n * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.\n *\n * When working with HTML you should always\n * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n * XSS vectors.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escape('fred, barney, & pebbles');\n * // => 'fred, barney, &amp; pebbles'\n */\nfunction escape(string) {\n  string = toString(string);\n  return (string && reHasUnescapedHtml.test(string))\n    ? string.replace(reUnescapedHtml, escapeHtmlChar)\n    : string;\n}\n\nmodule.exports = escape;\n\n\n//# sourceURL=webpack:///./node_modules/lodash.escape/index.js?");

/***/ }),

/***/ "./node_modules/open/index.js":
/*!************************************!*\
  !*** ./node_modules/open/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst {promisify} = __webpack_require__(/*! util */ \"util\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst isWsl = __webpack_require__(/*! is-wsl */ \"./node_modules/is-wsl/index.js\");\nconst isDocker = __webpack_require__(/*! is-docker */ \"./node_modules/is-docker/index.js\");\n\nconst pAccess = promisify(fs.access);\nconst pExecFile = promisify(childProcess.execFile);\n\n// Path to included `xdg-open`.\nconst localXdgOpenPath = path.join(__dirname, 'xdg-open');\n\n// Convert a path from WSL format to Windows format:\n// `/mnt/c/Program Files/Example/MyApp.exe` → `C:\\Program Files\\Example\\MyApp.exe`\nconst wslToWindowsPath = async path => {\n\tconst {stdout} = await pExecFile('wslpath', ['-w', path]);\n\treturn stdout.trim();\n};\n\nmodule.exports = async (target, options) => {\n\tif (typeof target !== 'string') {\n\t\tthrow new TypeError('Expected a `target`');\n\t}\n\n\toptions = {\n\t\twait: false,\n\t\tbackground: false,\n\t\turl: false,\n\t\tallowNonzeroExitCode: false,\n\t\t...options\n\t};\n\n\tlet command;\n\tlet appArguments = [];\n\tconst cliArguments = [];\n\tconst childProcessOptions = {};\n\n\tif (Array.isArray(options.app)) {\n\t\tappArguments = options.app.slice(1);\n\t\toptions.app = options.app[0];\n\t}\n\n\t// Encodes the target as if it were an URL. Especially useful to get\n\t// double-quotes through the “double-quotes on Windows caveat”, but it\n\t// can be used on any platform.\n\tif (options.url) {\n\t\ttarget = new url.URL(target).href;\n\n\t\tif (isWsl) {\n\t\t\ttarget = target.replace(/&/g, '^&');\n\t\t}\n\t}\n\n\tif (process.platform === 'darwin') {\n\t\tcommand = 'open';\n\n\t\tif (options.wait) {\n\t\t\tcliArguments.push('--wait-apps');\n\t\t}\n\n\t\tif (options.background) {\n\t\t\tcliArguments.push('--background');\n\t\t}\n\n\t\tif (options.app) {\n\t\t\tcliArguments.push('-a', options.app);\n\t\t}\n\t} else if (process.platform === 'win32' || (isWsl && !isDocker())) {\n\t\tcommand = 'cmd' + (isWsl ? '.exe' : '');\n\t\tcliArguments.push('/s', '/c', 'start', '\"\"', '/b');\n\n\t\tif (!isWsl) {\n\t\t\t// Always quoting target allows for URLs/paths to have spaces and unmarked characters, as `cmd.exe` will\n\t\t\t// interpret them as plain text to be forwarded as one unique argument. Enabling `windowsVerbatimArguments`\n\t\t\t// disables Node.js's default quotes and escapes handling (https://git.io/fjdem).\n\t\t\t// References:\n\t\t\t// - Issues #17, #44, #55, #77, #101, #115\n\t\t\t// - Pull requests: #74, #98\n\t\t\t//\n\t\t\t// As a result, all double-quotes are stripped from the `target` and do not get to your desired destination.\n\t\t\ttarget = `\"${target}\"`;\n\t\t\tchildProcessOptions.windowsVerbatimArguments = true;\n\n\t\t\tif (options.app) {\n\t\t\t\toptions.app = `\"${options.app}\"`;\n\t\t\t}\n\t\t}\n\n\t\tif (options.wait) {\n\t\t\tcliArguments.push('/wait');\n\t\t}\n\n\t\tif (options.app) {\n\t\t\tif (isWsl && options.app.startsWith('/mnt/')) {\n\t\t\t\tconst windowsPath = await wslToWindowsPath(options.app);\n\t\t\t\toptions.app = windowsPath;\n\t\t\t}\n\n\t\t\tcliArguments.push(options.app);\n\t\t}\n\n\t\tif (appArguments.length > 0) {\n\t\t\tcliArguments.push(...appArguments);\n\t\t}\n\t} else {\n\t\tif (options.app) {\n\t\t\tcommand = options.app;\n\t\t} else {\n\t\t\t// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.\n\t\t\tconst isBundled = !__dirname || __dirname === '/';\n\n\t\t\t// Check if local `xdg-open` exists and is executable.\n\t\t\tlet exeLocalXdgOpen = false;\n\t\t\ttry {\n\t\t\t\tawait pAccess(localXdgOpenPath, fs.constants.X_OK);\n\t\t\t\texeLocalXdgOpen = true;\n\t\t\t} catch (_) {}\n\n\t\t\tconst useSystemXdgOpen = process.versions.electron ||\n\t\t\t\tprocess.platform === 'android' || isBundled || !exeLocalXdgOpen;\n\t\t\tcommand = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;\n\t\t}\n\n\t\tif (appArguments.length > 0) {\n\t\t\tcliArguments.push(...appArguments);\n\t\t}\n\n\t\tif (!options.wait) {\n\t\t\t// `xdg-open` will block the process unless stdio is ignored\n\t\t\t// and it's detached from the parent even if it's unref'd.\n\t\t\tchildProcessOptions.stdio = 'ignore';\n\t\t\tchildProcessOptions.detached = true;\n\t\t}\n\t}\n\n\tcliArguments.push(target);\n\n\tif (process.platform === 'darwin' && appArguments.length > 0) {\n\t\tcliArguments.push('--args', ...appArguments);\n\t}\n\n\tconst subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);\n\n\tif (options.wait) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tsubprocess.once('error', reject);\n\n\t\t\tsubprocess.once('close', exitCode => {\n\t\t\t\tif (options.allowNonzeroExitCode && exitCode > 0) {\n\t\t\t\t\treject(new Error(`Exited with code ${exitCode}`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresolve(subprocess);\n\t\t\t});\n\t\t});\n\t}\n\n\tsubprocess.unref();\n\n\treturn subprocess;\n};\n\n\n//# sourceURL=webpack:///./node_modules/open/index.js?");

/***/ }),

/***/ "./src/bin/flamegraph.ts":
/*!*******************************!*\
  !*** ./src/bin/flamegraph.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar _a;\nvar _b;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cli = __webpack_require__(/*! @asgerf/strongcli */ \"./node_modules/@asgerf/strongcli/index.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar pathlib = __webpack_require__(/*! path */ \"path\");\nvar flamegraph_builder_1 = __webpack_require__(/*! ../common/flamegraph_builder */ \"./src/common/flamegraph_builder.ts\");\nvar escapeHtml = __webpack_require__(/*! lodash.escape */ \"./node_modules/lodash.escape/index.js\");\nvar Format;\n(function (Format) {\n    Format[\"html\"] = \"html\";\n    Format[\"trace\"] = \"trace\";\n})(Format || (Format = {}));\nvar program = cli.program({\n    helpIfEmpty: true,\n    positionalArgHint: '<logfile or database>',\n    description: \"\\n  Parses tuple counts from the given log file and generates a flamegraph of\\n  evaluated predicates weighted by tuple counts.\\n\\n  If given a database, the most recent log file from that database is used.\\n\"\n});\nvar _c = program.main({\n    outputFile: {\n        name: ['-o', '--output'],\n        value: String,\n        valueHint: 'file',\n        description: 'Where to write the output.',\n    },\n    format: {\n        value: cli.oneOf(Format),\n        default: Format.html,\n        description: \"\\nOutput format. Takes one of the following values:\\nhtml:  Static HTML file with d3-flame-graph. (the default)\\ntrace: Trace Event JSON file.\\n       Can be viewed in chrome://tracing or https://speedscope.app\\n\"\n    },\n    open: {\n        description: 'Open the generated HTML file in a browser.\\nHas no effect if not generating HTML.'\n    },\n    async: {\n        description: 'Use asynchronous parsing (for benchmarking)',\n    },\n    relative: {\n        description: 'Emit relative paths to files in flamegraph-viewer'\n    }\n}), options = _c.options, args = _c.args;\nvar input = args[0];\nif (!fs.existsSync(input)) {\n    cli.fail('File not found: ' + input);\n}\nif (fs.statSync(input).isDirectory()) {\n    var logDir = pathlib.join(input, 'log');\n    if (!fs.existsSync(logDir) || !fs.statSync(logDir).isDirectory()) {\n        cli.fail('Not a snapshot or log file: ' + input);\n    }\n    var logFiles = fs.readdirSync(logDir).filter(function (f) { return /^execute-queries-[\\d.]+\\.log$/.test(f); }).sort();\n    if (logFiles.length === 0) {\n        cli.fail('No logs in snapshot: ' + input);\n    }\n    input = pathlib.join(logDir, logFiles[logFiles.length - 1]);\n}\nvar outputFile = (_b = options.outputFile) !== null && _b !== void 0 ? _b : (options.format === Format.html ? 'flamegraph.html' : 'flamegraph.json');\nvar outputDir = pathlib.dirname(outputFile);\nfunction mkdirp(path) {\n    if (!fs.existsSync(path)) {\n        var parent_1 = pathlib.dirname(path);\n        if (parent_1.length < path.length) {\n            mkdirp(pathlib.dirname(path));\n        }\n        fs.mkdirSync(path);\n    }\n}\nmkdirp(outputDir);\nvar outputDataFile = outputFile + '.data.js';\nvar formatters = (_a = {},\n    _a[Format.html] = function (flamegraph) {\n        var ownDirectory = __dirname;\n        var htmlTemplateFile = pathlib.join(ownDirectory, 'flamegraph.html');\n        var htmlTemplateText = fs.readFileSync(htmlTemplateFile, 'utf8');\n        var pathToOwnDirectory = options.relative\n            ? pathlib.relative(outputDir, ownDirectory)\n            : ownDirectory;\n        var htmlText = htmlTemplateText\n            .replace(/(flamegraph_webmain\\.js|d3-flamegraph\\.css)/g, function (m) { return pathlib.join(pathToOwnDirectory, m); })\n            .replace('<!--%DATA%-->', \"<script src=\\\"\" + escapeHtml(pathlib.basename(outputDataFile)) + \"\\\"></script>\");\n        fs.writeFileSync(outputFile, htmlText, { encoding: 'utf8' });\n        var dataJs = 'window.codeqlFlamegraphData = ' + JSON.stringify(flamegraph);\n        fs.writeFileSync(outputFile + '.data.js', dataJs, { encoding: 'utf8' });\n        if (options.open) {\n            __webpack_require__(/*! open */ \"./node_modules/open/index.js\")(outputFile);\n        }\n    },\n    _a[Format.trace] = function (flamegraph) {\n        var traceEvents = [];\n        function writeNode(node, startTime) {\n            traceEvents.push({\n                ph: \"B\" /* TRACE_EVENT_PHASE_BEGIN */,\n                cat: 'p',\n                name: node.name,\n                pid: 0,\n                tid: 0,\n                ts: startTime,\n                args: {}\n            });\n            var currentTime = startTime;\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                writeNode(child, currentTime);\n                currentTime += child.value;\n            }\n            traceEvents.push({\n                ph: \"E\" /* TRACE_EVENT_PHASE_END */,\n                cat: 'p',\n                name: node.name,\n                pid: 0,\n                tid: 0,\n                ts: startTime + node.value,\n                args: {}\n            });\n        }\n        writeNode(flamegraph, 0);\n        var trace = {\n            traceEvents: traceEvents,\n            metadata: {}\n        };\n        fs.writeFileSync(outputFile, JSON.stringify(trace), { encoding: 'utf8' });\n    },\n    _a);\nfunction main() {\n    return __awaiter(this, void 0, void 0, function () {\n        var flamegraph, _a, formatter;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!options.async) return [3 /*break*/, 2];\n                    return [4 /*yield*/, flamegraph_builder_1.getFlamegraphFromLogStream(fs.createReadStream(input))];\n                case 1:\n                    _a = _b.sent();\n                    return [3 /*break*/, 3];\n                case 2:\n                    _a = flamegraph_builder_1.getFlamegraphFromLogText(fs.readFileSync(input, 'utf8'));\n                    _b.label = 3;\n                case 3:\n                    flamegraph = _a;\n                    formatter = formatters[options.format];\n                    formatter(flamegraph);\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nmain();\n\n\n//# sourceURL=webpack:///./src/bin/flamegraph.ts?");

/***/ }),

/***/ "./src/common/dominators.ts":
/*!**********************************!*\
  !*** ./src/common/dominators.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDominanceRelation = void 0;\nfunction getDominanceRelation(roots, successors) {\n    var NodeData = /** @class */ (function () {\n        function NodeData(node) {\n            this.node = node;\n            this.predecessors = new Set();\n        }\n        return NodeData;\n    }());\n    var syntheticRoot = new NodeData(null);\n    var nodeData = new Map();\n    var postOrderNodes = [];\n    function getNodeData(node) {\n        var data = nodeData.get(node);\n        if (data == null) {\n            data = new NodeData(node);\n            nodeData.set(node, data);\n        }\n        return data;\n    }\n    function visitPostOrder(node, pred) {\n        var data = getNodeData(node);\n        if (pred != null) {\n            data.predecessors.add(pred);\n        }\n        if (data.postOrderId != null) {\n            return;\n        }\n        data.postOrderId = -1; // break cycles\n        successors(node).forEach(function (succ) { return visitPostOrder(succ, node); });\n        data.postOrderId = postOrderNodes.length;\n        postOrderNodes.push(data);\n    }\n    roots.forEach(function (root) { return visitPostOrder(root, undefined); });\n    syntheticRoot.postOrderId = postOrderNodes.length;\n    roots.forEach(function (root) {\n        var data = getNodeData(root);\n        data.dominator = syntheticRoot;\n    });\n    function intersect(b1, b2) {\n        while (b1 !== b2) {\n            while (b1.postOrderId < b2.postOrderId) {\n                b1 = b1.dominator;\n            }\n            while (b2.postOrderId < b1.postOrderId) {\n                b2 = b2.dominator;\n            }\n        }\n        return b1;\n    }\n    var changed = true;\n    while (changed) {\n        changed = false;\n        var _loop_1 = function (i) {\n            var data = postOrderNodes[i];\n            var oldDominator = data.dominator;\n            data.predecessors.forEach(function (pred) {\n                var predData = getNodeData(pred);\n                if (predData.dominator === undefined) {\n                    return;\n                }\n                if (data.dominator === undefined) {\n                    data.dominator = predData;\n                }\n                else {\n                    data.dominator = intersect(data.dominator, predData);\n                }\n            });\n            if (oldDominator !== data.dominator) {\n                changed = true;\n            }\n        };\n        for (var i = postOrderNodes.length - 1; i >= 0; --i) {\n            _loop_1(i);\n        }\n    }\n    var resultMap = new Map();\n    postOrderNodes.forEach(function (data) {\n        if (data.node != null) {\n            resultMap.set(data.node, data.dominator.node);\n        }\n    });\n    return resultMap;\n}\nexports.getDominanceRelation = getDominanceRelation;\n\n\n//# sourceURL=webpack:///./src/common/dominators.ts?");

/***/ }),

/***/ "./src/common/event_stream.ts":
/*!************************************!*\
  !*** ./src/common/event_stream.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncStreamBuilder = exports.SyncStreamBuilder = exports.EventStream = void 0;\n/**\n * A list of event handlers for a given type of event.\n *\n * An object that exposes an event stream in a field will typically fire\n * its events, while users of the object can listen to the stream.\n */\nvar EventStream = /** @class */ (function () {\n    function EventStream() {\n        this.listeners = [];\n    }\n    /** Calls all listeners with the given event. */\n    EventStream.prototype.fire = function (event) {\n        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n            var listener = _a[_i];\n            listener(event);\n        }\n    };\n    /** Adds an event listener to be invoked when an event is fired. */\n    EventStream.prototype.listen = function (listener) {\n        this.listeners.push(listener);\n    };\n    return EventStream;\n}());\nexports.EventStream = EventStream;\n/**\n * Helper for composing long streams before firing off the input events synchronously.\n *\n * Correct use of streams requires that all listeners have been added before any\n * events are fired. Otherwise the events are lost since we don't buffer the events.\n *\n * The stream builder knows how to trigger the input events synchronously, and encapsulates a value of type\n * `T` which is considered \"ready\" once all input events have fired.\n * The `.get` method triggers all input events and then returns the underlying value.\n */\nvar SyncStreamBuilder = /** @class */ (function () {\n    function SyncStreamBuilder(fire, value) {\n        this.fire = fire;\n        this.value = value;\n    }\n    /**\n     * Adds a consumer of the current stream value and returns the result boxed in a stream builder.\n     */\n    SyncStreamBuilder.prototype.then = function (transformer) {\n        return new SyncStreamBuilder(this.fire, transformer(this.value));\n    };\n    /**\n     * Adds a consumer of the current stream value and returns the result boxed in a stream builder.\n     */\n    SyncStreamBuilder.prototype.thenNew = function (transformer) {\n        return new SyncStreamBuilder(this.fire, new transformer(this.value));\n    };\n    /** Fires all input events and then returns the boxed value. */\n    SyncStreamBuilder.prototype.get = function () {\n        this.fire();\n        return this.value;\n    };\n    return SyncStreamBuilder;\n}());\nexports.SyncStreamBuilder = SyncStreamBuilder;\n/**\n * Helper for composing long streams and then waiting for the input stream to end.\n *\n * Correct use of streams requires that all the listeners have been added before any\n * events are fired. Otherwise the events are lost since we don't buffer the events.\n *\n * The stream builder knows when the input stream has ended, and encapsulates a value of type `T`\n * which is considered \"ready\" once all inputs events have fired.\n * The `.get` returns a promise for the underlying value when it is ready.\n */\nvar AsyncStreamBuilder = /** @class */ (function () {\n    function AsyncStreamBuilder(end, value) {\n        this.end = end;\n        this.value = value;\n    }\n    /**\n     * Adds a consumer of the current stream value and returns the result boxed in a stream builder.\n     */\n    AsyncStreamBuilder.prototype.then = function (transformer) {\n        return new AsyncStreamBuilder(this.end, transformer(this.value));\n    };\n    /**\n     * Adds a consumer of the current stream value and returns the result boxed in a stream builder.\n     */\n    AsyncStreamBuilder.prototype.thenNew = function (transformer) {\n        return new AsyncStreamBuilder(this.end, new transformer(this.value));\n    };\n    /** Waits for the input stream to end, then returns the boxed value. */\n    AsyncStreamBuilder.prototype.get = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this.end.listen(function () {\n                resolve(_this.value);\n            });\n        });\n    };\n    return AsyncStreamBuilder;\n}());\nexports.AsyncStreamBuilder = AsyncStreamBuilder;\n\n\n//# sourceURL=webpack:///./src/common/event_stream.ts?");

/***/ }),

/***/ "./src/common/flamegraph_builder.ts":
/*!******************************************!*\
  !*** ./src/common/flamegraph_builder.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlamegraphBuilder = exports.getFlamegraphFromLogStream = exports.getFlamegraphFromLogText = void 0;\nvar dominators_1 = __webpack_require__(/*! ./dominators */ \"./src/common/dominators.ts\");\nvar line_stream_1 = __webpack_require__(/*! ./line_stream */ \"./src/common/line_stream.ts\");\nvar string_set_abbreviation_1 = __webpack_require__(/*! ./string_set_abbreviation */ \"./src/common/string_set_abbreviation.ts\");\nvar strongly_connected_components_1 = __webpack_require__(/*! ./strongly_connected_components */ \"./src/common/strongly_connected_components.ts\");\nvar tuple_counts_1 = __webpack_require__(/*! ./tuple_counts */ \"./src/common/tuple_counts.ts\");\nvar util_1 = __webpack_require__(/*! ./util */ \"./src/common/util.ts\");\nfunction getFlamegraphFromLogText(text) {\n    return line_stream_1.streamLinesSync(text).thenNew(tuple_counts_1.TupleCountParser).thenNew(FlamegraphBuilder).get().finish();\n}\nexports.getFlamegraphFromLogText = getFlamegraphFromLogText;\nfunction getFlamegraphFromLogStream(stream) {\n    return line_stream_1.streamLinesAsync(stream).thenNew(tuple_counts_1.TupleCountParser).thenNew(FlamegraphBuilder).get().then(function (x) { return x.finish(); });\n}\nexports.getFlamegraphFromLogStream = getFlamegraphFromLogStream;\nvar PredicateNode = /** @class */ (function () {\n    function PredicateNode(name) {\n        this.name = name;\n        this.tupleCount = 0;\n        this.dependencies = new Set();\n        this.dependents = new Set();\n        this.seenEvaluation = false;\n        this.rawLines = [];\n    }\n    return PredicateNode;\n}());\nfunction rewritePredicateName(name) {\n    return name.replace(/(#(cur_delta|prev_delta|prev)|@staged_ext|_delta)$/, '');\n}\nvar FlamegraphBuilder = /** @class */ (function () {\n    function FlamegraphBuilder(input) {\n        this.predicateNodes = new Map();\n        this.stageNodes = [];\n        input.onPipeline.listen(this.onPipeline.bind(this));\n        input.onStageEnded.listen(this.onStageEnded.bind(this));\n    }\n    FlamegraphBuilder.prototype.getPredicateNode = function (name) {\n        var result = this.predicateNodes.get(name);\n        if (result == null) {\n            result = new PredicateNode(name);\n            this.predicateNodes.set(name, result);\n        }\n        return result;\n    };\n    FlamegraphBuilder.prototype.onStageEnded = function (event) {\n        this.stageNodes.push(this.getFlamegraphNodeFromStage(event));\n        this.predicateNodes.clear();\n    };\n    FlamegraphBuilder.prototype.onPipeline = function (pipeline) {\n        var name = rewritePredicateName(pipeline.predicate);\n        var node = this.getPredicateNode(name);\n        node.seenEvaluation = true;\n        for (var _i = 0, _a = pipeline.steps; _i < _a.length; _i++) {\n            var step = _a[_i];\n            if (!tuple_counts_1.isUnionOperator(step.raText)) {\n                node.tupleCount += step.tupleCount;\n            }\n            for (var _b = 0, _c = tuple_counts_1.getDependenciesFromRA(step.raText).inputRelations; _b < _c.length; _b++) {\n                var otherRelation = _c[_b];\n                otherRelation = rewritePredicateName(otherRelation);\n                node.dependencies.add(otherRelation);\n                this.getPredicateNode(otherRelation).dependents.add(name);\n            }\n        }\n        node.rawLines.push(pipeline.rawLines);\n    };\n    FlamegraphBuilder.prototype.getRoots = function () {\n        var roots = [];\n        this.predicateNodes.forEach(function (data, name) {\n            if (data.dependents.size === 0) {\n                roots.push(name);\n            }\n        });\n        return roots;\n    };\n    FlamegraphBuilder.prototype.getFlamegraphNodeFromPredicate = function (predicate, dominated, successors) {\n        var node = this.getPredicateNode(predicate);\n        if (!node.seenEvaluation) {\n            return undefined;\n        }\n        var children = [];\n        for (var _i = 0, successors_1 = successors; _i < successors_1.length; _i++) {\n            var successor = successors_1[_i];\n            var child = this.getFlamegraphNodeFromScc(successor, dominated);\n            if (child != null) {\n                children.push(child);\n            }\n        }\n        var value = node.tupleCount + totalValue(children);\n        return {\n            name: node.name,\n            value: value,\n            ownValue: node.tupleCount,\n            children: children,\n            rawLines: node.rawLines,\n        };\n    };\n    FlamegraphBuilder.prototype.getFlamegraphNodeFromScc = function (scc, dominated) {\n        var _this = this;\n        var _a, _b;\n        var members = scc.members;\n        if (members.length === 1) {\n            return this.getFlamegraphNodeFromPredicate(members[0], dominated, (_a = dominated.get(scc)) !== null && _a !== void 0 ? _a : []);\n        }\n        var name = string_set_abbreviation_1.abbreviateStrings(members);\n        var children = [];\n        for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n            var member = members_1[_i];\n            var child = this.getFlamegraphNodeFromPredicate(member, dominated, []);\n            if (child != null) {\n                children.push(child);\n            }\n        }\n        var successors = (_b = dominated.get(scc)) !== null && _b !== void 0 ? _b : [];\n        successors.forEach(function (otherScc) {\n            var child = _this.getFlamegraphNodeFromScc(otherScc, dominated);\n            if (child != null) {\n                children.push(child);\n            }\n        });\n        return {\n            name: name,\n            value: totalValue(children),\n            children: children,\n        };\n    };\n    FlamegraphBuilder.prototype.getFlamegraphNodeFromStage = function (stage) {\n        var _this = this;\n        var roots = this.getRoots();\n        var predicates = Array.from(this.predicateNodes.keys());\n        var sccMap = strongly_connected_components_1.getStronglyConnectedComponents(predicates, function (pred) { return _this.getPredicateNode(pred).dependencies; });\n        sccMap.nodes.forEach(function (scc, predicate) {\n            _this.getPredicateNode(predicate).scc = scc;\n        });\n        var rootSccs = roots.map(function (r) { return sccMap.nodes.get(r); });\n        var sccDominators = dominators_1.getDominanceRelation(rootSccs, function (scc) { return scc.successors; });\n        var sccDominated = util_1.getInverse(sccDominators);\n        var levelOneNodes = util_1.withoutNulls(rootSccs.map(function (n) { return _this.getFlamegraphNodeFromScc(n, sccDominated); }));\n        return {\n            kind: 'Stage',\n            name: string_set_abbreviation_1.abbreviateStrings(stage.queryPredicates),\n            value: totalValue(levelOneNodes),\n            children: levelOneNodes,\n        };\n    };\n    FlamegraphBuilder.prototype.finish = function () {\n        var children = this.stageNodes;\n        return {\n            name: 'root',\n            value: totalValue(children),\n            children: children,\n        };\n    };\n    return FlamegraphBuilder;\n}());\nexports.FlamegraphBuilder = FlamegraphBuilder;\nfunction totalValue(children) {\n    return children.reduce(function (x, y) { return x + y.value; }, 0);\n}\n\n\n//# sourceURL=webpack:///./src/common/flamegraph_builder.ts?");

/***/ }),

/***/ "./src/common/line_stream.ts":
/*!***********************************!*\
  !*** ./src/common/line_stream.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.streamLinesAsync = exports.streamLinesSync = exports.LineStream = void 0;\nvar event_stream_1 = __webpack_require__(/*! ./event_stream */ \"./src/common/event_stream.ts\");\n/**\n * Reads data line by line and invokes event handlers with associated regexps.\n */\nvar LineStream = /** @class */ (function () {\n    function LineStream() {\n        this.matchers = [];\n        /** Event fired when there are no more lines to parse. */\n        this.end = new event_stream_1.EventStream();\n        /** Number of lines seen so far. */\n        this.lineNumber = 0;\n    }\n    /** Adds a line and immediately invokes all matching event handlers. */\n    LineStream.prototype.addLine = function (line) {\n        for (var _i = 0, _a = this.matchers; _i < _a.length; _i++) {\n            var matcher = _a[_i];\n            var match = matcher.pattern.exec(line);\n            if (match != null) {\n                matcher.callback(match);\n            }\n            else {\n                var negativeCallback = matcher.negativeCallback;\n                if (negativeCallback != null) {\n                    negativeCallback(line);\n                }\n            }\n        }\n        ++this.lineNumber;\n    };\n    LineStream.prototype.addLines = function (lines) {\n        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n            var line = lines_1[_i];\n            this.addLine(line);\n        }\n        return this;\n    };\n    /** Marks the end of the file, firing the `end` event. */\n    LineStream.prototype.addEof = function () {\n        this.end.fire();\n    };\n    /** Splits a text and invokes `addLine` for each line. */\n    LineStream.prototype.addText = function (text) {\n        this.addLines(text.split(/\\r?\\n/));\n        this.addEof();\n    };\n    /**\n     * Listens for lines matching `pattern` and invokes `callback` on a match,\n     * and `negativeCallback` (if provided) for any line that does not match.\n     */\n    LineStream.prototype.on = function (pattern, callback, negativeCallback) {\n        this.matchers.push({ pattern: pattern, callback: callback, negativeCallback: negativeCallback });\n        return this;\n    };\n    return LineStream;\n}());\nexports.LineStream = LineStream;\n/** Creates a `LineStream` and feeds it the given text once listeners have been added. */\nfunction streamLinesSync(text) {\n    var parser = new LineStream();\n    return new event_stream_1.SyncStreamBuilder(function () { return parser.addText(text); }, parser);\n}\nexports.streamLinesSync = streamLinesSync;\n/** Creates a `LineStream` from the given NodeJS stream. */\nfunction streamLinesAsync(stream) {\n    var parser = new LineStream();\n    var readline = __webpack_require__(/*! readline */ \"readline\");\n    var reader = readline.createInterface(stream);\n    reader.on('line', function (line) {\n        parser.addLine(line);\n    });\n    reader.on('close', function () {\n        parser.addEof();\n    });\n    return new event_stream_1.AsyncStreamBuilder(parser.end, parser);\n}\nexports.streamLinesAsync = streamLinesAsync;\n\n\n//# sourceURL=webpack:///./src/common/line_stream.ts?");

/***/ }),

/***/ "./src/common/string_set_abbreviation.ts":
/*!***********************************************!*\
  !*** ./src/common/string_set_abbreviation.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.abbreviateStrings = void 0;\n/**\n * Returns a string whose brace expansion would result in the given set of strings.\n *\n * Braces are only inserted following a `::` token.\n *\n * For example, the strings `foo::bar` and `foo:baz` would abbreviate to `foo::{bar, baz}`, and not `foo::ba{r,z}`.\n */\nfunction abbreviateStrings(strings) {\n    var trie = new Map();\n    strings.forEach(function (str) {\n        var parts = str.split('::');\n        var currentNode = trie;\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            var value = currentNode.get(part);\n            if (value == null) {\n                var map = new Map();\n                currentNode.set(part, map);\n                currentNode = map;\n            }\n            else {\n                currentNode = value;\n            }\n        }\n    });\n    function stringifyNode(node) {\n        var parts = [];\n        node.forEach(function (value, key) {\n            parts.push(key + stringifyNodeSuffix(value));\n        });\n        return parts.join(', ');\n    }\n    function stringifyNodeSuffix(node) {\n        if (node.size === 0) {\n            return '';\n        }\n        else if (node.size > 1) {\n            return '::{' + stringifyNode(node) + '}';\n        }\n        else {\n            return '::' + stringifyNode(node);\n        }\n    }\n    return stringifyNode(trie);\n}\nexports.abbreviateStrings = abbreviateStrings;\n\n\n//# sourceURL=webpack:///./src/common/string_set_abbreviation.ts?");

/***/ }),

/***/ "./src/common/strongly_connected_components.ts":
/*!*****************************************************!*\
  !*** ./src/common/strongly_connected_components.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getStronglyConnectedComponents = exports.Scc = void 0;\nvar Scc = /** @class */ (function () {\n    function Scc(index) {\n        this.index = index;\n        this.members = [];\n        this.successors = new Set();\n    }\n    return Scc;\n}());\nexports.Scc = Scc;\nfunction getStronglyConnectedComponents(roots, successors) {\n    var NodeData = /** @class */ (function () {\n        function NodeData(node, index) {\n            this.node = node;\n            this.index = index;\n            this.successorSccs = [];\n            this.lowlink = index;\n        }\n        NodeData.prototype.onStack = function () {\n            return this.scc == null;\n        };\n        return NodeData;\n    }());\n    var nextIndex = 0;\n    var nodeDatas = new Map();\n    var stack = [];\n    var sccs = [];\n    var sccNodes = new Map();\n    function visit(node) {\n        var data = nodeDatas.get(node);\n        if (data != null) {\n            return data;\n        }\n        data = new NodeData(node, nextIndex++);\n        nodeDatas.set(node, data);\n        stack.push(data);\n        successors(node).forEach(function (succ) {\n            var succData = nodeDatas.get(succ);\n            if (succData == null) {\n                succData = visit(succ);\n                data.lowlink = Math.min(data.lowlink, succData.lowlink);\n            }\n            else if (succData.onStack()) {\n                data.lowlink = Math.min(data.lowlink, succData.index);\n            }\n            var succScc = succData.scc;\n            if (succScc != null) {\n                data.successorSccs.push(succScc);\n            }\n        });\n        if (data.lowlink === data.index) {\n            var scc = new Scc(sccs.length);\n            sccs.push(scc);\n            var current = void 0;\n            do {\n                current = stack.pop();\n                current.scc = scc;\n                sccNodes.set(current.node, scc);\n                scc.members.push(current.node);\n                for (var _i = 0, _a = current.successorSccs; _i < _a.length; _i++) {\n                    var succScc = _a[_i];\n                    scc.successors.add(succScc);\n                }\n            } while (current !== data);\n        }\n        return data;\n    }\n    roots.forEach(visit);\n    return { nodes: sccNodes, sccs: sccs };\n}\nexports.getStronglyConnectedComponents = getStronglyConnectedComponents;\n\n\n//# sourceURL=webpack:///./src/common/strongly_connected_components.ts?");

/***/ }),

/***/ "./src/common/tuple_counts.ts":
/*!************************************!*\
  !*** ./src/common/tuple_counts.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isUnionOperator = exports.getDependenciesFromRA = exports.streamTupleCounts = exports.TupleCountParser = void 0;\nvar event_stream_1 = __webpack_require__(/*! ./event_stream */ \"./src/common/event_stream.ts\");\nvar TupleCountParser = /** @class */ (function () {\n    function TupleCountParser(input) {\n        var _this = this;\n        this.input = input;\n        this.onPipeline = new event_stream_1.EventStream();\n        this.onPredicateSize = new event_stream_1.EventStream();\n        this.onStageEnded = new event_stream_1.EventStream();\n        /**\n         * Set to true if the evaluation of a predicate was seen in the\n         * parsed log.\n         *\n         * Can be used to diagnose cases where no tuple counts were found,\n         * indicating if this was a log without tuple counts, or not a log\n         * file at all.\n         */\n        this.seenPredicateEvaluation = false;\n        this.end = input.end;\n        var seenCsvImbQueriesHeader = false;\n        input.on(/CSV_IMB_QUERIES:\\s*(.*)/, function (_a) {\n            var whole = _a[0], row = _a[1];\n            if (!seenCsvImbQueriesHeader) {\n                seenCsvImbQueriesHeader = true;\n                return;\n            }\n            var _b = row.split(','), queryType = _b[0], queryPredicateStr = _b[1], queryName = _b[2], stage = _b[3], success = _b[4], time = _b[5], numResult = _b[6], cumulativeTime = _b[7];\n            var queryPredicates = queryPredicateStr.split(' ');\n            _this.onStageEnded.fire({\n                queryPredicates: queryPredicates,\n                queryName: queryName,\n            });\n        });\n        var currentPredicateName = null;\n        var currentPipelineSteps = [];\n        var currentPredicateLine = 0;\n        var currentRawLines = [];\n        input.on(/Starting to evaluate predicate (.*)\\/.*/, function (match) {\n            var name = match[1];\n            _this.seenPredicateEvaluation = true;\n            currentPredicateName = name;\n            currentPredicateLine = input.lineNumber;\n            currentRawLines.push(match.input);\n        });\n        input.on(/Tuple counts for (.*):$/, function (match) {\n            var name = match[1];\n            _this.seenPredicateEvaluation = true;\n            name = name.replace(/\\@\\w+$/, '').replace(/\\/\\d+/, '');\n            currentPredicateName = name;\n            currentPredicateLine = input.lineNumber;\n            currentRawLines.push(match.input);\n        });\n        var parseRelationSize = function (_a) {\n            var name = _a[1], rows = _a[2];\n            _this.onPredicateSize.fire({\n                predicate: name,\n                size: Number(rows),\n            });\n        };\n        input.on(/>>> Relation ([\\w#:]+): (\\d+) rows/, parseRelationSize);\n        input.on(/>>> Wrote relation ([\\w#:]+) with (\\d+) rows/, parseRelationSize);\n        input.on(/- ([\\w#:]+) has (\\d+) rows/, parseRelationSize);\n        input.on(/Found relation ([\\w#:]+)\\b.*\\bRelation has (\\d+) rows/, parseRelationSize);\n        input.on(/(\\d+)\\s+(?:~(\\d+)%)?\\s+[{](\\d+)[}]\\s+r(\\d+)\\s+=\\s+(.*)/, function (match) {\n            var tupleCountStr = match[1], duplicationStr = match[2], arityStr = match[3], resultVariable = match[4], raText = match[5];\n            var tupleCount = Number(tupleCountStr);\n            var duplication = Number(duplicationStr);\n            var arity = Number(arityStr);\n            currentPipelineSteps.push({\n                tupleCount: tupleCount,\n                duplication: duplication,\n                arity: arity,\n                raText: raText,\n            });\n            currentRawLines.push(match.input);\n        }, function (line) {\n            if (line.trim().length === 0) {\n                return;\n            }\n            if (currentPipelineSteps.length > 0 && currentPredicateName != null) {\n                _this.onPipeline.fire({\n                    predicate: currentPredicateName,\n                    steps: currentPipelineSteps,\n                    startLine: currentPredicateLine,\n                    endLine: input.lineNumber,\n                    rawLines: currentRawLines,\n                });\n                currentPipelineSteps = [];\n                currentRawLines = [];\n                currentPredicateName = null;\n            }\n        });\n    }\n    return TupleCountParser;\n}());\nexports.TupleCountParser = TupleCountParser;\nfunction streamTupleCounts(input) {\n    return new TupleCountParser(input);\n}\nexports.streamTupleCounts = streamTupleCounts;\nfunction allMatches(regexp, input) {\n    if (!regexp.flags.includes('g')) {\n        throw new Error('allMatches requires a RegExp with /g flag');\n    }\n    var match;\n    var result = [];\n    while ((match = regexp.exec(input)) != null) {\n        result.push(match);\n    }\n    return result;\n}\nfunction getDependenciesFromRA(racode) {\n    var inputVariables = new Set();\n    var inputRelations = new Set();\n    var stripped = racode.replace(/\"[^\"]+\"/g, '\"\"');\n    for (var _i = 0, _a = allMatches(/(?<!HIGHER-ORDER RELATION |PRIMITIVE |[$@#])\\b[a-zA-Z#][\\w:#_]+\\b(?!\\()/g, stripped); _i < _a.length; _i++) {\n        var ref = _a[_i][0];\n        if (/^([A-Z]+|true|false)$/.test(ref)) {\n            continue;\n        } // Probably an RA keyword\n        if (/^r\\d+$/.test(ref)) {\n            inputVariables.add(Number(ref.substring(1)));\n        }\n        else {\n            inputRelations.add(ref);\n        }\n    }\n    return {\n        inputVariables: Array.from(inputVariables),\n        inputRelations: Array.from(inputRelations)\n    };\n}\nexports.getDependenciesFromRA = getDependenciesFromRA;\nfunction isUnionOperator(raText) {\n    return raText.includes('\\\\/');\n}\nexports.isUnionOperator = isUnionOperator;\n\n\n//# sourceURL=webpack:///./src/common/tuple_counts.ts?");

/***/ }),

/***/ "./src/common/util.ts":
/*!****************************!*\
  !*** ./src/common/util.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLowerBound = exports.doNothing = exports.withoutNulls = exports.asArray = exports.getInverse = exports.mapIncrement = exports.multiMapRemove = exports.getSet = exports.getMap = exports.getArray = void 0;\nfunction getArray(map, key) {\n    var result = map.get(key);\n    if (result == null) {\n        result = [];\n        map.set(key, result);\n    }\n    return result;\n}\nexports.getArray = getArray;\nfunction getMap(map, key) {\n    var result = map.get(key);\n    if (result == null) {\n        result = new Map();\n        map.set(key, result);\n    }\n    return result;\n}\nexports.getMap = getMap;\nfunction getSet(map, key) {\n    var result = map.get(key);\n    if (result == null) {\n        result = new Set();\n        map.set(key, result);\n    }\n    return result;\n}\nexports.getSet = getSet;\nfunction multiMapRemove(map, key, value) {\n    var set = map.get(key);\n    if (set == null) {\n        return false;\n    }\n    if (set.delete(value)) {\n        if (set.size === 0) {\n            map.delete(key);\n        }\n        return true;\n    }\n    return false;\n}\nexports.multiMapRemove = multiMapRemove;\nfunction mapIncrement(map, key, delta) {\n    var _a;\n    var value = (_a = map.get(key)) !== null && _a !== void 0 ? _a : 0;\n    map.set(key, value + delta);\n}\nexports.mapIncrement = mapIncrement;\nfunction getInverse(map) {\n    var result = new Map();\n    map.forEach(function (value, key) {\n        getArray(result, value).push(key);\n    });\n    return result;\n}\nexports.getInverse = getInverse;\nfunction asArray(x) {\n    if (x == null) {\n        return [];\n    }\n    if (Array.isArray(x)) {\n        return x;\n    }\n    return [x];\n}\nexports.asArray = asArray;\nfunction withoutNulls(array) {\n    return array.filter(function (x) { return x != null; });\n}\nexports.withoutNulls = withoutNulls;\nexports.doNothing = function () { return undefined; };\n/**\n * Returns the index of the last element of `array` that is less than or equal to `value`,\n * or -1 if all elements are greater than `value`.\n *\n * The array must be sorted and non-empty.\n */\nfunction getLowerBound(array, value) {\n    var low = 0, high = array.length - 1;\n    if (value < array[0]) {\n        return -1;\n    }\n    if (value >= array[high]) {\n        return high;\n    }\n    while (low < high) {\n        var mid = high - ((high - low) >> 1); // Get middle, rounding up.\n        if (value < array[mid]) {\n            high = mid - 1;\n        }\n        else {\n            low = mid;\n        }\n    }\n    return low;\n}\nexports.getLowerBound = getLowerBound;\n\n\n//# sourceURL=webpack:///./src/common/util.ts?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"child_process\");\n\n//# sourceURL=webpack:///external_%22child_process%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack:///external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "readline":
/*!***************************!*\
  !*** external "readline" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"readline\");\n\n//# sourceURL=webpack:///external_%22readline%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack:///external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ })

/******/ });